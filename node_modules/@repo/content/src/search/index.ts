// Content search utilities for the platform
import { ContentItem, ContentIndex, createContentIndex, searchContent } from '../indexing';

export interface SearchResult {
  item: ContentItem;
  score: number;
  highlights?: string[];
}

export interface SearchOptions {
  limit?: number;
  offset?: number;
  includeHighlights?: boolean;
  fuzzy?: boolean;
}

// Enhanced search with scoring and highlights
export const enhancedSearch = (
  index: ContentIndex,
  query: string,
  options: SearchOptions = {}
): SearchResult[] => {
  const { limit = 20, offset = 0, includeHighlights = false, fuzzy = false } = options;
  
  // If fuzzy search is enabled, we'd implement more sophisticated matching
  // For now, we'll use the basic search
  const results = searchContent(index, query);
  
  // Score results based on relevance (title match > description match > content match)
  const scoredResults: SearchResult[] = results.map(item => {
    let score = 0;
    
    // Title match is worth more
    if (item.title.toLowerCase().includes(query.toLowerCase())) {
      score += 10;
    }
    
    // Description match
    if (item.description && item.description.toLowerCase().includes(query.toLowerCase())) {
      score += 5;
    }
    
    // Content match
    if (item.content.toLowerCase().includes(query.toLowerCase())) {
      score += 1;
    }
    
    // Tag match
    if (item.tags && item.tags.some(tag => 
      tag.toLowerCase().includes(query.toLowerCase())
    )) {
      score += 3;
    }
    
    const result: SearchResult = {
      item,
      score,
    };
    
    // Add highlights if requested
    if (includeHighlights) {
      const highlights = generateHighlights(item, query);
      if (highlights.length > 0) {
        result.highlights = highlights;
      }
    }
    
    return result;
  });
  
  // Sort by score (descending)
  scoredResults.sort((a, b) => b.score - a.score);
  
  // Apply pagination
  return scoredResults.slice(offset, offset + limit);
};

// Generate highlights around search terms
const generateHighlights = (item: ContentItem, query: string): string[] => {
  if (!item.content) {
    return [];
  }
  
  const queryWords = query.toLowerCase().split(/\W+/).filter(Boolean);
  if (queryWords.length === 0) {
    return [];
  }
  
  const content = item.content.toLowerCase();
  const highlights: string[] = [];
  const maxLength = 150; // Max length of each highlight
  const contextLength = 50; // Length of context around match
  
  for (const word of queryWords) {
    const wordIndex = content.indexOf(word);
    if (wordIndex !== -1) {
      // Get context around the match
      let start = Math.max(0, wordIndex - contextLength);
      let end = Math.min(content.length, wordIndex + word.length + contextLength);
      
      // Adjust to word boundaries
      while (start > 0 && content[start] !== ' ' && content[start] !== '.' && content[start] !== ',') {
        start--;
      }
      
      while (end < content.length && content[end] !== ' ' && content[end] !== '.' && content[end] !== ',') {
        end++;
      }
      
      // Extract the context
      let context = item.content.substring(start, end);
      
      // Truncate if too long
      if (context.length > maxLength) {
        context = context.substring(0, maxLength) + '...';
      }
      
      // Highlight the search term
      context = context.replace(
        new RegExp(`(${word})`, 'gi'),
        '<mark>$1</mark>'
      );
      
      if (!highlights.includes(context)) {
        highlights.push(context);
      }
    }
  }
  
  return highlights;
};

// Search filter functions
export const searchFilters = {
  // Filter by tags
  byTags: (results: SearchResult[], tags: string[]): SearchResult[] => {
    if (!tags || tags.length === 0) return results;
    
    return results.filter(result => {
      if (!result.item.tags) return false;
      return tags.some(tag => result.item.tags?.includes(tag));
    });
  },
  
  // Filter by content type
  byType: (results: SearchResult[], type: string): SearchResult[] => {
    return results.filter(result => 
      result.item.metadata?.type === type
    );
  },
  
  // Filter by date range
  byDate: (
    results: SearchResult[], 
    startDate?: Date, 
    endDate?: Date
  ): SearchResult[] => {
    return results.filter(result => {
      const itemDate = result.item.updatedAt || result.item.createdAt;
      if (startDate && itemDate < startDate) return false;
      if (endDate && itemDate > endDate) return false;
      return true;
    });
  },
};

// Create a searchable index from content items
export const createSearchableIndex = (items: ContentItem[]): ContentIndex => {
  return createContentIndex(items);
};

// Search with filters applied
export const searchWithFilters = (
  index: ContentIndex,
  query: string,
  filters?: {
    tags?: string[];
    type?: string;
    startDate?: Date;
    endDate?: Date;
  },
  options: SearchOptions = {}
): SearchResult[] => {
  // Perform initial search
  const results = enhancedSearch(index, query, options);
  
  // Apply filters
  let filteredResults = [...results];
  
  if (filters?.tags) {
    filteredResults = searchFilters.byTags(filteredResults, filters.tags);
  }
  
  if (filters?.type) {
    filteredResults = searchFilters.byType(filteredResults, filters.type);
  }
  
  if (filters?.startDate || filters?.endDate) {
    filteredResults = searchFilters.byDate(
      filteredResults, 
      filters.startDate, 
      filters.endDate
    );
  }
  
  return filteredResults;
};