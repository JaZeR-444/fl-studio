// Content loading utilities for the platform
import { ContentItem, ContentManifest } from '../index';

export interface ContentLoaderOptions {
  manifestPath?: string;
  sourcePath: string;
  include?: string[];
  exclude?: string[];
  transform?: (content: string) => string;
}

// Base content loader
export abstract class ContentLoader {
  protected options: ContentLoaderOptions;

  constructor(options: ContentLoaderOptions) {
    this.options = options;
  }

  abstract load(): Promise<ContentItem[]>;
  abstract loadManifest(): Promise<ContentManifest>;
}

// Static content loader for HTML files
export class StaticContentLoader extends ContentLoader {
  async load(): Promise<ContentItem[]> {
    // In a real implementation, this would read and parse files from the source path
    // For now, we'll simulate loading content
    console.log(`Loading static content from ${this.options.sourcePath}`);

    // Simulated content items
    const contentItems: ContentItem[] = [
      {
        id: 'static-content-1',
        title: 'Static Content Example',
        description: 'A sample static content item',
        content: '<h1>Static Content</h1><p>This is an example of static content loaded from the source.</p>',
        tags: ['static', 'example'],
        sourcePath: this.options.sourcePath,
        createdAt: new Date(),
        updatedAt: new Date(),
      }
    ];

    return contentItems;
  }

  async loadManifest(): Promise<ContentManifest> {
    // In a real implementation, this would load the manifest from the source
    return {
      id: 'static-content-manifest',
      name: 'Static Content Manifest',
      version: '1.0.0',
      description: 'Manifest for static content',
      sourcePath: this.options.sourcePath,
      files: [
        {
          id: 'file-1',
          name: 'content.html',
          path: `${this.options.sourcePath}/content.html`,
          type: 'text/html',
          size: 1024,
          hash: 'abc123',
        }
      ],
      createdAt: new Date(),
      updatedAt: new Date(),
    };
  }
}

// JSON content loader for structured data
export class JsonContentLoader extends ContentLoader {
  async load(): Promise<ContentItem[]> {
    // In a real implementation, this would read and parse JSON files from the source path
    console.log(`Loading JSON content from ${this.options.sourcePath}`);

    // Simulated JSON content items
    const contentItems: ContentItem[] = [
      {
        id: 'json-content-1',
        title: 'JSON Data Example',
        description: 'A sample JSON content item',
        content: JSON.stringify({ example: 'data', type: 'json' }),
        tags: ['json', 'data'],
        sourcePath: this.options.sourcePath,
        createdAt: new Date(),
        updatedAt: new Date(),
        metadata: { dataType: 'json' }
      }
    ];

    return contentItems;
  }

  async loadManifest(): Promise<ContentManifest> {
    return {
      id: 'json-content-manifest',
      name: 'JSON Content Manifest',
      version: '1.0.0',
      description: 'Manifest for JSON content',
      sourcePath: this.options.sourcePath,
      files: [
        {
          id: 'file-1',
          name: 'data.json',
          path: `${this.options.sourcePath}/data.json`,
          type: 'application/json',
          size: 512,
          hash: 'def456',
        }
      ],
      createdAt: new Date(),
      updatedAt: new Date(),
    };
  }
}

// Factory function to create appropriate loader
export const createContentLoader = (options: ContentLoaderOptions): ContentLoader => {
  // Determine loader type based on source path or options
  if (options.sourcePath.endsWith('.json') || options.include?.some(pattern => pattern.endsWith('.json'))) {
    return new JsonContentLoader(options);
  }

  return new StaticContentLoader(options);
};

// Load content using the appropriate loader
export const loadContent = async (options: ContentLoaderOptions): Promise<ContentItem[]> => {
  const loader = createContentLoader(options);
  return await loader.load();
};

// Load content manifest
export const loadContentManifest = async (options: ContentLoaderOptions): Promise<ContentManifest> => {
  const loader = createContentLoader(options);
  return await loader.loadManifest();
};