// Content transformation utilities for the platform
import { ContentItem } from '../index';

// Transformation functions
export interface ContentTransformer {
  (content: ContentItem): ContentItem;
}

// Common transformations
export const transformations = {
  // Convert HTML to plain text
  htmlToText: (content: ContentItem): ContentItem => {
    // Create a temporary DOM element to extract text content
    const temp = typeof document !== 'undefined' 
      ? document.createElement('div') 
      : { innerHTML: content.content } as any;
    
    if ('innerHTML' in temp) {
      temp.innerHTML = content.content;
      const text = temp.textContent || temp.innerText || '';
      return {
        ...content,
        content: text,
      };
    }
    
    return content;
  },

  // Extract headings from content
  extractHeadings: (content: ContentItem): ContentItem => {
    const headingRegex = /<h[1-6][^>]*>(.*?)<\/h[1-6]>/gi;
    const headings = [];
    let match;

    while ((match = headingRegex.exec(content.content)) !== null) {
      headings.push(match[1]);
    }

    return {
      ...content,
      metadata: {
        ...content.metadata,
        headings,
      },
    };
  },

  // Add word count metadata
  addWordCount: (content: ContentItem): ContentItem => {
    const textContent = content.content.replace(/<[^>]*>/g, ' '); // Remove HTML tags
    const words = textContent.trim().split(/\s+/).filter(Boolean);
    const wordCount = words.length;

    return {
      ...content,
      metadata: {
        ...content.metadata,
        wordCount,
      },
    };
  },

  // Add reading time estimate (assuming 200 words per minute)
  addReadingTime: (content: ContentItem): ContentItem => {
    if (!content.metadata || content.metadata.wordCount === undefined) {
      // If word count doesn't exist, calculate it
      const textContent = content.content.replace(/<[^>]*>/g, ' ');
      const words = textContent.trim().split(/\s+/).filter(Boolean);
      const wordCount = words.length;

      const readingTime = Math.ceil(wordCount / 200); // Minutes

      return {
        ...content,
        metadata: {
          ...content.metadata,
          wordCount,
          readingTime,
        },
      };
    }

    const readingTime = Math.ceil(content.metadata.wordCount / 200);
    return {
      ...content,
      metadata: {
        ...content.metadata,
        readingTime,
      },
    };
  },

  // Sanitize HTML content (basic implementation)
  sanitizeHtml: (content: ContentItem): ContentItem => {
    // Remove potentially dangerous tags/attributes
    // In a real implementation, use a proper HTML sanitizer like DOMPurify
    let sanitizedContent = content.content;

    // Remove script tags
    sanitizedContent = sanitizedContent.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');

    // Remove event handlers
    sanitizedContent = sanitizedContent.replace(/on\w+="[^"]*"/gi, '');

    return {
      ...content,
      content: sanitizedContent,
    };
  },
};

// Apply a transformation to content
export const applyTransformation = (content: ContentItem, transformer: ContentTransformer): ContentItem => {
  return transformer(content);
};

// Apply multiple transformations in sequence
export const applyTransformations = (content: ContentItem, transformers: ContentTransformer[]): ContentItem => {
  return transformers.reduce((acc, transformer) => transformer(acc), content);
};

// Common transformation pipelines
export const pipelines = {
  // Basic content processing pipeline
  basic: [
    transformations.sanitizeHtml,
    transformations.addWordCount,
    transformations.addReadingTime,
  ] as ContentTransformer[],

  // Content for search indexing
  forSearch: [
    transformations.sanitizeHtml,
    transformations.htmlToText,
    transformations.addWordCount,
  ] as ContentTransformer[],

  // Content with headings extracted
  withHeadings: [
    transformations.sanitizeHtml,
    transformations.extractHeadings,
    transformations.addWordCount,
    transformations.addReadingTime,
  ] as ContentTransformer[],
};

// Apply a named pipeline to content
export const applyPipeline = (content: ContentItem, pipelineName: keyof typeof pipelines): ContentItem => {
  const pipeline = pipelines[pipelineName];
  if (!pipeline) {
    throw new Error(`Unknown pipeline: ${pipelineName}`);
  }

  return applyTransformations(content, pipeline);
};