// Content indexing utilities for the platform
export interface ContentItem {
  id: string;
  title: string;
  description?: string;
  content: string;
  tags?: string[];
  sourcePath?: string;
  createdAt: Date;
  updatedAt: Date;
  metadata?: Record<string, any>;
}

export interface ContentIndex {
  items: ContentItem[];
  tags: string[];
  searchIndex: Map<string, string[]>; // word -> item IDs
}

// Index content for search and retrieval
export const createContentIndex = (items: ContentItem[]): ContentIndex => {
  const index: ContentIndex = {
    items,
    tags: [],
    searchIndex: new Map(),
  };

  // Extract all unique tags
  const allTags = new Set<string>();
  items.forEach(item => {
    if (item.tags) {
      item.tags.forEach(tag => allTags.add(tag));
    }
  });
  index.tags = Array.from(allTags);

  // Build search index
  items.forEach(item => {
    // Index title
    const titleWords = item.title.toLowerCase().split(/\W+/).filter(Boolean);
    titleWords.forEach(word => {
      if (!index.searchIndex.has(word)) {
        index.searchIndex.set(word, []);
      }
      index.searchIndex.get(word)!.push(item.id);
    });

    // Index description
    if (item.description) {
      const descWords = item.description.toLowerCase().split(/\W+/).filter(Boolean);
      descWords.forEach(word => {
        if (!index.searchIndex.has(word)) {
          index.searchIndex.set(word, []);
        }
        index.searchIndex.get(word)!.push(item.id);
      });
    }

    // Index content
    const contentWords = item.content.toLowerCase().split(/\W+/).filter(Boolean);
    contentWords.forEach(word => {
      if (!index.searchIndex.has(word)) {
        index.searchIndex.set(word, []);
      }
      index.searchIndex.get(word)!.push(item.id);
    });
  });

  return index;
};

// Search content by query
export const searchContent = (index: ContentIndex, query: string): ContentItem[] => {
  if (!query.trim()) {
    return index.items;
  }

  const queryWords = query.toLowerCase().split(/\W+/).filter(Boolean);
  if (queryWords.length === 0) {
    return index.items;
  }

  // Find items that contain all query words
  let matchingItemIds: string[] = [];
  
  for (const word of queryWords) {
    const itemIds = index.searchIndex.get(word);
    if (!itemIds) {
      // If a word has no matches, return empty results
      return [];
    }
    
    if (matchingItemIds.length === 0) {
      // First word - include all matches
      matchingItemIds = [...itemIds];
    } else {
      // Subsequent words - find intersection with existing matches
      matchingItemIds = matchingItemIds.filter(id => itemIds.includes(id));
    }
  }

  // Return matching items in original order
  return index.items.filter(item => matchingItemIds.includes(item.id));
};

// Filter content by tags
export const filterContentByTags = (items: ContentItem[], tags: string[]): ContentItem[] => {
  if (tags.length === 0) {
    return items;
  }

  return items.filter(item => {
    if (!item.tags) return false;
    return tags.some(tag => item.tags!.includes(tag));
  });
};